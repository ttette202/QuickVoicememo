<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Keepãƒ¬ã‚³ãƒ¼ãƒ€ãƒ¼ v22</title>
    <style>
        /* --- ãƒ‡ã‚¶ã‚¤ãƒ³ (v21ãƒ™ãƒ¼ã‚¹) --- */
        body { font-family: -apple-system, sans-serif; background: #f4f7f6; color: #333; margin: 0; padding-bottom: 120px; overscroll-behavior-y: none; }
        header { background: #fff; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 10; }
        h1 { margin: 0; font-size: 18px; color: #2c3e50; }
        .menu-btn { background: none; border: none; font-size: 24px; cursor: pointer; padding: 0; }
        
        #menuOverlay { display: none; position: absolute; top: 55px; right: 10px; background: #2c3e50; color: white; border-radius: 8px; padding: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); width: 280px; flex-direction: column; gap: 10px; z-index: 100; }
        #menuOverlay.open { display: flex; }
        .menu-item { background: rgba(255,255,255,0.1); border: none; color: white; padding: 10px; border-radius: 5px; cursor: pointer; text-align: left; font-size: 14px; width: 100%; box-sizing: border-box; }

        .switch-container { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; color: white; font-size: 14px; }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #3498db; }
        input:checked + .slider:before { transform: translateX(16px); }

        .storage-info { font-size: 12px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-bottom: 5px; }
        .storage-bar-bg { width: 100%; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .storage-bar-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.5s; }

        #libraryContainer { padding: 20px 15px; max-width: 800px; margin: 0 auto; }
        .folder-section { background: white; border-radius: 12px; margin-bottom: 20px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.3s ease; }
        .folder-header { background: #ecf0f1; padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; font-weight: bold; color: #2c3e50; }
        
        .folder-actions { display: flex; align-items: center; gap: 10px; }
        .pin-btn { background: none; border: none; font-size: 18px; cursor: pointer; opacity: 0.3; transition: 0.2s; }
        .pin-btn.active { opacity: 1; transform: scale(1.2); }
        .delete-folder-btn { border: none; background: none; color: #95a5a6; cursor: pointer; }

        .list-item { padding: 15px; border-bottom: 1px solid #eee; }
        .item-top-row { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .item-info { font-size: 13px; color: #333; font-weight: 500; }
        .item-meta { font-size: 11px; color: #999; margin-left: 8px; font-weight: normal; }
        
        /* ãƒ¡ãƒ¢è¡¨ç¤ºã‚¨ãƒªã‚¢ */
        .item-memo-display {
            font-size: 12px; color: #555; background: #fff8e1; padding: 8px 12px; 
            border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #f1c40f;
            white-space: pre-wrap; /* æ”¹è¡Œã‚’åæ˜  */
        }

        .item-controls { display: flex; align-items: center; gap: 10px; }
        .icon-btn { background: none; border: none; cursor: pointer; font-size: 16px; padding: 5px; color: #7f8c8d; }
        .delete-btn { color: #e74c3c; }
        audio { width: 100%; height: 32px; }

        .fab-container { position: fixed; bottom: 30px; right: 30px; display: flex; flex-direction: column; gap: 20px; z-index: 50; }
        .fab-btn { width: 70px; height: 70px; border-radius: 50%; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; color: white; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        #addFolderFab { background: #3498db; font-size: 28px; } #addFolderFab::after { content: "ğŸ“+"; font-size: 16px; }
        #startFab { background: #e74c3c; font-size: 32px; } #startFab::before { content: "ğŸ™ï¸"; }
        
        .overlay-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(44, 62, 80, 0.95); z-index: 200; flex-direction: column; justify-content: center; align-items: center; color: white; backdrop-filter: blur(5px); }
        .overlay-screen.active { display: flex; }
        .folder-select-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 500px; max-height: 70vh; overflow-y: auto; padding: 20px;}
        .folder-btn { background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 20px; border-radius: 12px; font-weight: bold; cursor: pointer; text-align: center; }
        .close-overlay-btn { margin-top: 30px; background: none; border: none; color: #ccc; text-decoration: underline; cursor: pointer; }
        .recording-status { font-size: 24px; margin-bottom: 10px; font-weight: bold; }
        .quality-badge { font-size: 12px; background: #3498db; padding: 2px 8px; border-radius: 4px; margin-bottom: 20px; display: none; }
        .timer-display { font-size: 48px; font-family: monospace; margin-bottom: 50px; }
        .big-stop-btn { width: 100px; height: 100px; border-radius: 50%; background: white; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .big-stop-btn div { width: 30px; height: 30px; background: #e74c3c; border-radius: 4px; }
        .review-controls { display: flex; flex-direction: column; gap: 15px; width: 300px; }
        .action-btn { padding: 15px; border-radius: 50px; font-weight: bold; border: none; cursor: pointer; }
        .btn-resume { background: #3498db; color: white; }
        .btn-save { background: #2ecc71; color: white; margin-top: 10px; }
        .btn-discard { background: transparent; color: #e74c3c; border: 1px solid #e74c3c; margin-top: 10px; }
        #loader { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.8); z-index:999; justify-content:center; align-items:center; color:#333; font-weight:bold; }
        #loader.active { display: flex; }

        #lockScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a252f; color: white; z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #pinInput { font-size: 24px; padding: 10px; text-align: center; letter-spacing: 5px; border: none; border-bottom: 2px solid white; background: transparent; color: white; width: 150px; margin-bottom: 20px; outline: none; }
        .unlock-btn { background: #e74c3c; color: white; border: none; padding: 10px 30px; font-size: 16px; border-radius: 50px; font-weight: bold; cursor: pointer; }

        #recTitleInput { width: 100%; max-width: 300px; padding: 15px; font-size: 16px; border-radius: 8px; border: none; outline: none; margin-bottom: 10px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        /* ãƒ¡ãƒ¢ç·¨é›†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #memoInputArea { width: 80%; max-width: 400px; height: 150px; padding: 15px; font-size: 16px; border-radius: 8px; border: none; margin-bottom: 20px; resize: none; font-family: sans-serif; }

        /* ã‚´ãƒŸç®± */
        #trashOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f4f7f6; z-index: 150; overflow-y: auto; padding: 20px; box-sizing: border-box; }
        #trashOverlay.active { display: block; }
        .trash-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #ddd; }
        .trash-list { list-style: none; padding: 0; }
        .trash-item { background: white; padding: 15px; margin-bottom: 10px; border-radius: 8px; border-left: 5px solid #7f8c8d; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .trash-info { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 12px; color: #555; }
        .trash-actions { display: flex; gap: 10px; justify-content: flex-end; }
        .btn-restore { background: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-purge { background: #e74c3c; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .empty-trash-btn { background: #c0392b; color: white; border: none; padding: 10px 20px; border-radius: 50px; cursor: pointer; font-weight: bold; width: 100%; margin-bottom: 20px; }

    </style>
</head>
<body>
    
    <div id="lockScreen">
        <div style="margin-bottom:20px; font-size:40px;">ğŸ”’</div>
        <p>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›</p>
        <input type="password" id="pinInput" maxlength="4" placeholder="****">
        <button class="unlock-btn" onclick="checkPin()">è§£é™¤</button>
        <p id="pinError" style="color:#e74c3c; height:20px; margin-top:10px;"></p>
    </div>

    <header>
        <h1>â˜ï¸ Keepãƒ¬ã‚³ãƒ¼ãƒ€ãƒ¼ v22</h1>
        <button class="menu-btn" onclick="toggleMenu()">â˜°</button>
        
        <div id="menuOverlay">
            <div class="switch-container">
                <span>ğŸ’ é«˜éŸ³è³ªãƒ¢ãƒ¼ãƒ‰</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="hqToggle" onchange="toggleHQ(this)">
                    <span class="slider"></span>
                </label>
            </div>
            <div style="font-size:10px; color:#aaa; margin-bottom:10px;">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ON</div>

            <div class="storage-info">
                <div>â˜ï¸ ä½¿ç”¨é‡ (ç›®å®‰)</div>
                <div style="font-size:16px; font-weight:bold; margin:5px 0;" id="usageText">è¨ˆç®—ä¸­...</div>
                <div class="storage-bar-bg"><div class="storage-bar-fill" id="usageBar"></div></div>
                <div style="font-size:10px; opacity:0.7; margin-top:5px;">ä¸Šé™: 5GB (ç„¡æ–™æ )</div>
            </div>
            
            <button class="menu-item" onclick="openTrash()" style="margin-top:10px;">ğŸ—‘ï¸ ã‚´ãƒŸç®±ã‚’è¦‹ã‚‹</button>
            <button class="menu-item" onclick="manualLock()" style="border:1px solid #e74c3c; background:rgba(231,76,60,0.1); color:#e74c3c; margin-top:10px;">ğŸ”’ ã™ãã«ãƒ­ãƒƒã‚¯ã™ã‚‹</button>
        </div>
    </header>

    <div id="loader">å‡¦ç†ä¸­...</div>

    <div id="trashOverlay">
        <div class="trash-header">
            <h2 style="margin:0;">ğŸ—‘ï¸ ã‚´ãƒŸç®±</h2>
            <button onclick="closeTrash()" style="background:none; border:none; font-size:24px; cursor:pointer;">Ã—</button>
        </div>
        <p style="font-size:12px; color:#666; margin-bottom:15px;">â€»å‰Šé™¤ã‹ã‚‰15æ—¥çµŒéã™ã‚‹ã¨è‡ªå‹•çš„ã«æ¶ˆå»ã•ã‚Œã¾ã™ã€‚</p>
        <button class="empty-trash-btn" onclick="emptyTrashAll()">âš ï¸ ã‚´ãƒŸç®±ã‚’ç©ºã«ã™ã‚‹</button>
        <ul id="trashList" class="trash-list"></ul>
    </div>

    <div id="libraryContainer">
        <p style="text-align:center; color:#ccc; margin-top:50px;">èª­ã¿è¾¼ã¿ä¸­...</p>
    </div>

    <div class="fab-container">
        <button id="addFolderFab" class="fab-btn" onclick="createNewFolderDirect()"></button>
        <button id="startFab" class="fab-btn" onclick="openFolderSelector()"></button>
    </div>

    <div id="folderOverlay" class="overlay-screen">
        <h3>ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ</h3>
        <div id="folderGrid" class="folder-select-grid"></div>
        <button class="close-overlay-btn" onclick="closeAllOverlays()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>

    <div id="recordingOverlay" class="overlay-screen">
        <div class="recording-status">ğŸ”´ éŒ²éŸ³ä¸­</div>
        <div id="hqBadge" class="quality-badge">ğŸ’ High Quality</div>
        <div class="timer-display" id="timer">00:00</div>
        <div id="currentFolderDisplay" style="margin-bottom:10px; opacity:0.7;"></div>
        <button class="big-stop-btn" onclick="pauseForReview()"><div></div></button>
    </div>

    <div id="reviewOverlay" class="overlay-screen">
        <div style="font-size:18px; margin-bottom:20px;">ä¸€æ™‚åœæ­¢ä¸­</div>
        <audio id="previewPlayer" controls style="width:100%; max-width:300px; margin-bottom:20px;"></audio>
        <input type="text" id="recTitleInput" placeholder="ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ› (ä»»æ„)">
        <div class="review-controls">
            <button class="action-btn btn-resume" onclick="resumeRecording()">â†©ï¸ å†é–‹</button>
            <button class="action-btn btn-save" onclick="confirmSave()">â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜</button>
            <button class="action-btn btn-discard" onclick="confirmDiscard()">ğŸ—‘ï¸ ç ´æ£„</button>
        </div>
    </div>

    <!-- ãƒ¡ãƒ¢ç·¨é›†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <div id="memoEditOverlay" class="overlay-screen">
        <h3>ğŸ“ ãƒ¡ãƒ¢ã‚’ç·¨é›†</h3>
        <textarea id="memoInputArea" placeholder="ã“ã“ã«ãƒ¡ãƒ¢ã‚’å…¥åŠ›..."></textarea>
        <div class="review-controls">
            <button class="action-btn btn-save" onclick="saveMemo()">ä¿å­˜</button>
            <button class="action-btn btn-discard" onclick="closeMemoEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, deleteDoc, doc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

        // â–¼â–¼â–¼ ã“ã“ã«Firebaseã®è¨­å®šã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ â–¼â–¼â–¼
          const firebaseConfig = {
  apiKey: "AIzaSyANfuSVeic8GkhnRA107VkdZczHTgw2oEM",
  authDomain: "web-recorder-37128.firebaseapp.com",
  projectId: "web-recorder-37128",
  storageBucket: "web-recorder-37128.firebasestorage.app",
  messagingSenderId: "347477125584",
  appId: "1:347477125584:web:9d893502dbed76686e71d5"
        };
        // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // ãƒ­ãƒƒã‚¯æ©Ÿèƒ½
        const KEEP_UNLOCKED_DURATION = 7 * 24 * 60 * 60 * 1000; 
        const lastUnlockTime = localStorage.getItem('voiceAppLastUnlock');
        if (lastUnlockTime && (Date.now() - parseInt(lastUnlockTime) < KEEP_UNLOCKED_DURATION)) {
            document.getElementById('lockScreen').style.display = 'none';
            setTimeout(() => initRealtimeListener(), 100);
        }

        window.checkPin = () => {
            const input = document.getElementById('pinInput');
            if(input.value === "1027") {
                localStorage.setItem('voiceAppLastUnlock', Date.now());
                document.getElementById('lockScreen').style.display = 'none';
                initRealtimeListener();
            } else {
                document.getElementById('pinError').textContent = "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™";
                input.value = "";
            }
        };
        window.manualLock = () => {
            if(!confirm("ã‚¢ãƒ—ãƒªã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ")) return;
            localStorage.removeItem('voiceAppLastUnlock');
            location.reload();
        };

        // UIæ“ä½œ
        window.toggleMenu = () => document.getElementById('menuOverlay').classList.toggle('open');
        window.closeAllOverlays = () => document.querySelectorAll('.overlay-screen').forEach(el => el.classList.remove('active'));
        const loader = document.getElementById('loader');

        // é«˜éŸ³è³ªè¨­å®š
        let isHighQuality = true; 
        if (localStorage.getItem('voiceAppHQ') === 'false') {
            isHighQuality = false;
            document.getElementById('hqToggle').checked = false;
        } else {
            isHighQuality = true;
            document.getElementById('hqToggle').checked = true;
        }
        window.toggleHQ = (checkbox) => {
            isHighQuality = checkbox.checked;
            localStorage.setItem('voiceAppHQ', isHighQuality);
        };

        function formatBytes(bytes, decimals = 1) {
            if (!bytes) return '';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        let mediaRecorder = null, masterAudioChunks = [], targetFolder = "", timerInterval, startTime, elapsedTime = 0;
        let foldersCache = [];
        let recordingsCache = [];
        let editingMemoId = null; // ãƒ¡ãƒ¢ç·¨é›†ä¸­ã®ID

        function initRealtimeListener() {
            const container = document.getElementById('libraryContainer');
            const qRecs = query(collection(db, "recordings"), orderBy("date", "desc"));
            const qFolders = query(collection(db, "folders"));

            const render = () => {
                checkAutoDelete(recordingsCache);
                container.innerHTML = '';
                const activeRecordings = recordingsCache.filter(r => !r.isDeleted);
                
                let totalBytes = 0;
                recordingsCache.forEach(r => { if(r.filesize) totalBytes += r.filesize; });
                updateStorageDisplay(totalBytes);

                if(foldersCache.length === 0) {
                    container.innerHTML = '<p style="text-align:center;color:#999;margin-top:50px;">å³ä¸‹ã®ãƒœã‚¿ãƒ³ã§ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã¦ãã ã•ã„</p>';
                    return;
                }
                
                foldersCache.sort((a, b) => {
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;
                    const timeA = new Date(a.lastUpdatedAt || a.createdAt).getTime();
                    const timeB = new Date(b.lastUpdatedAt || b.createdAt).getTime();
                    return timeB - timeA;
                });

                foldersCache.forEach(folder => {
                    const recs = activeRecordings.filter(r => r.folder === folder.name);
                    const div = document.createElement('div'); div.className = 'folder-section';
                    
                    let listHtml = recs.length ? recs.map(r => {
                        let displayName = r.displayName || new Date(r.date).toLocaleString();
                        let sizeStr = formatBytes(r.filesize);
                        let memoHtml = r.memo ? `<div class="item-memo-display">${r.memo}</div>` : '';

                        return `
                        <li class="list-item">
                            <div class="item-top-row">
                                <div class="item-info">
                                    ${displayName} <span class="item-meta">(${sizeStr})</span>
                                </div>
                                <div class="item-controls">
                                    <button class="icon-btn" onclick="window.openMemoEditor('${r.id}', '${encodeURIComponent(r.memo || '')}')">ğŸ“</button>
                                    <button class="icon-btn delete-btn" onclick="window.moveToTrash('${r.id}')">ğŸ—‘ï¸</button>
                                </div>
                            </div>
                            ${memoHtml}
                            <audio controls src="${r.url}" preload="none"></audio>
                        </li>`;
                    }).join('') : '<div style="padding:15px;color:#ccc;text-align:center;font-size:12px">ãƒ‡ãƒ¼ã‚¿ãªã—</div>';
                    
                    const pinClass = folder.isPinned ? "active" : "";
                    const pinIcon = folder.isPinned ? "ğŸ“Œ" : "ğŸ“";

                    div.innerHTML = `
                        <div class="folder-header">
                            <div class="folder-actions">
                                <button class="pin-btn ${pinClass}" onclick="window.togglePin('${folder.id}', ${folder.isPinned})">${pinIcon}</button>
                                <span>${folder.name}</span>
                            </div>
                            <button class="delete-folder-btn" onclick="window.deleteFolder('${folder.name}')">Ã—</button>
                        </div>
                        <ul style="list-style:none;padding:0;margin:0;">${listHtml}</ul>
                    `;
                    container.appendChild(div);
                });
            };

            onSnapshot(qFolders, (snap) => { foldersCache = snap.docs.map(d => ({id: d.id, ...d.data()})); render(); });
            onSnapshot(qRecs, (snap) => { recordingsCache = snap.docs.map(d => ({id: d.id, ...d.data()})); render(); });
        }

        // --- ãƒ¡ãƒ¢æ©Ÿèƒ½ ---
        window.openMemoEditor = (id, currentMemoEncoded) => {
            editingMemoId = id;
            document.getElementById('memoInputArea').value = decodeURIComponent(currentMemoEncoded);
            document.getElementById('memoEditOverlay').classList.add('active');
        };

        window.closeMemoEditor = () => {
            document.getElementById('memoEditOverlay').classList.remove('active');
            editingMemoId = null;
        };

        window.saveMemo = async () => {
            if (!editingMemoId) return;
            const text = document.getElementById('memoInputArea').value;
            loader.classList.add('active');
            try {
                await updateDoc(doc(db, "recordings", editingMemoId), { memo: text });
                window.closeMemoEditor();
            } catch(e) { alert("ä¿å­˜ã‚¨ãƒ©ãƒ¼: " + e.message); }
            loader.classList.remove('active');
        };

        async function checkAutoDelete(allRecs) {
            const now = Date.now();
            const DAY_15_MS = 15 * 24 * 60 * 60 * 1000;
            const toDelete = allRecs.filter(r => {
                if (!r.isDeleted || !r.deletedAt) return false;
                return (now - new Date(r.deletedAt).getTime()) > DAY_15_MS;
            });
            if (toDelete.length > 0) {
                for (const r of toDelete) await window.deleteRecPermanently(r.id, r.storagePath);
            }
        }

        window.openTrash = () => {
            const trashList = document.getElementById('trashList');
            trashList.innerHTML = '';
            const deletedRecs = recordingsCache.filter(r => r.isDeleted);
            if (deletedRecs.length === 0) {
                trashList.innerHTML = '<p style="text-align:center;color:#999;">ã‚´ãƒŸç®±ã¯ç©ºã§ã™</p>';
            } else {
                deletedRecs.sort((a,b) => new Date(b.deletedAt) - new Date(a.deletedAt));
                deletedRecs.forEach(r => {
                    const li = document.createElement('li'); li.className = 'trash-item';
                    const remainingMs = (15 * 24 * 60 * 60 * 1000) - (Date.now() - new Date(r.deletedAt).getTime());
                    const remainingDays = Math.ceil(remainingMs / (24 * 60 * 60 * 1000));
                    let displayName = r.displayName || new Date(r.date).toLocaleString();
                    let sizeStr = formatBytes(r.filesize);

                    li.innerHTML = `
                        <div style="font-weight:bold; margin-bottom:5px;">${displayName} <span style="font-size:11px; color:#999;">(${sizeStr})</span></div>
                        <div class="trash-info"><span>ğŸ“‚ ${r.folder}</span><span style="color:#e74c3c">ã‚ã¨${remainingDays}æ—¥ã§å‰Šé™¤</span></div>
                        <audio controls src="${r.url}" preload="none" style="width:100%; margin-bottom:10px;"></audio>
                        <div class="trash-actions">
                            <button class="btn-restore" onclick="window.restoreRec('${r.id}')">â†©ï¸ å¾©å…ƒ</button>
                            <button class="btn-purge" onclick="window.deleteRecPermanently('${r.id}', '${r.storagePath}', true)">ğŸ—‘ï¸ å®Œå…¨å‰Šé™¤</button>
                        </div>
                    `;
                    trashList.appendChild(li);
                });
            }
            window.toggleMenu();
            document.getElementById('trashOverlay').classList.add('active');
        };
        window.closeTrash = () => document.getElementById('trashOverlay').classList.remove('active');
        window.moveToTrash = async (id) => {
            if(!confirm("ã‚´ãƒŸç®±ã¸ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ")) return;
            loader.classList.add('active');
            try { await updateDoc(doc(db, "recordings", id), { isDeleted: true, deletedAt: new Date().toISOString() }); } catch(e){ alert(e.message); }
            loader.classList.remove('active');
        };
        window.restoreRec = async (id) => {
            if(!confirm("å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ")) return;
            loader.classList.add('active');
            try { await updateDoc(doc(db, "recordings", id), { isDeleted: false, deletedAt: null }); window.openTrash(); } catch(e){ alert(e.message); }
            loader.classList.remove('active');
        };
        window.deleteRecPermanently = async (id, storagePath, isManual=false) => {
            if(isManual && !confirm("å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nå¾©å…ƒã§ãã¾ã›ã‚“ã€‚")) return;
            if(isManual) loader.classList.add('active');
            try {
                const fileRef = ref(storage, storagePath);
                await deleteObject(fileRef).catch(e => console.log("File gone"));
                await deleteDoc(doc(db, "recordings", id));
                if(isManual) window.openTrash();
            } catch(e) { if(isManual) alert("å‰Šé™¤ã‚¨ãƒ©ãƒ¼"); }
            if(isManual) loader.classList.remove('active');
        };
        window.emptyTrashAll = async () => {
            if(!confirm("ã‚´ãƒŸç®±ã‚’ç©ºã«ã—ã¾ã™ã‹ï¼Ÿ")) return;
            loader.classList.add('active');
            const deletedRecs = recordingsCache.filter(r => r.isDeleted);
            for (const r of deletedRecs) await window.deleteRecPermanently(r.id, r.storagePath, false);
            window.openTrash();
            loader.classList.remove('active');
        };

        function updateStorageDisplay(bytes) {
            const limit = 5 * 1024 * 1024 * 1024; 
            const percent = Math.min(100, (bytes / limit) * 100);
            document.getElementById('usageText').textContent = `${(bytes/1024/1024).toFixed(1)} MB / 5 GB`;
            document.getElementById('usageBar').style.width = `${percent}%`;
        }

        window.createNewFolderDirect = async () => {
            const name = prompt("ãƒ•ã‚©ãƒ«ãƒ€å:");
            if(name && name.trim()) {
                loader.classList.add('active');
                try {
                    await setDoc(doc(db, "folders", name.trim()), {
                        name: name.trim(), createdAt: new Date().toISOString(), lastUpdatedAt: new Date().toISOString(), isPinned: false
                    });
                } catch(e) { alert("ã‚¨ãƒ©ãƒ¼: " + e.message); }
                loader.classList.remove('active');
            }
        };

        window.togglePin = async (folderId, currentState) => {
            try { await updateDoc(doc(db, "folders", folderId), { isPinned: !currentState }); } catch(e) { console.error(e); }
        };

        window.openFolderSelector = () => {
            const grid = document.getElementById('folderGrid');
            grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;">èª­ã¿è¾¼ã¿ä¸­...</div>';
            document.getElementById('folderOverlay').classList.add('active');
            import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js").then(({ getDocs, query, collection }) => {
                getDocs(query(collection(db, "folders"))).then(snap => {
                    grid.innerHTML = '';
                    if(snap.empty) {
                        grid.innerHTML = '<div class="folder-btn" style="grid-column:1/-1" onclick="window.createNewFolderDirect()">ãƒ•ã‚©ãƒ«ãƒ€ä½œæˆ</div>';
                    } else {
                        let folders = snap.docs.map(d => d.data());
                        folders.sort((a, b) => {
                            if (a.isPinned && !b.isPinned) return -1;
                            if (!a.isPinned && b.isPinned) return 1;
                            return new Date(b.lastUpdatedAt || b.createdAt) - new Date(a.lastUpdatedAt || a.createdAt);
                        });
                        folders.forEach(f => {
                            const btn = document.createElement('div');
                            btn.className = 'folder-btn'; btn.textContent = f.name;
                            btn.onclick = () => startRecordingProcess(f.name);
                            grid.appendChild(btn);
                        });
                    }
                });
            });
        };

        async function startRecordingProcess(folderName) {
            targetFolder = folderName; masterAudioChunks = []; elapsedTime = 0;
            window.closeAllOverlays();
            document.getElementById('recordingOverlay').classList.add('active');
            document.getElementById('currentFolderDisplay').textContent = folderName;
            
            const badge = document.getElementById('hqBadge');
            const constraints = { audio: true };
            if (isHighQuality) {
                constraints.audio = { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 2 };
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                const options = isHighQuality ? { audioBitsPerSecond: 256000 } : {};
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.addEventListener('dataavailable', e => { if (e.data.size > 0) masterAudioChunks.push(e.data); });
                mediaRecorder.start();
                startTimer();
            } catch(e) { alert("ãƒã‚¤ã‚¯è¨±å¯ãŒå¿…è¦ã§ã™"); window.closeAllOverlays(); }
        }

        window.pauseForReview = () => {
            if(mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.requestData(); mediaRecorder.pause(); stopTimer();
                setTimeout(() => {
                    window.closeAllOverlays();
                    document.getElementById('reviewOverlay').classList.add('active');
                    document.getElementById('recTitleInput').value = ''; 
                    const blob = new Blob(masterAudioChunks, { type: 'audio/webm' });
                    document.getElementById('previewPlayer').src = URL.createObjectURL(blob);
                }, 100);
            }
        };

        window.resumeRecording = () => {
            if(mediaRecorder && mediaRecorder.state === 'paused') {
                window.closeAllOverlays();
                document.getElementById('recordingOverlay').classList.add('active');
                mediaRecorder.resume(); startTimer();
            }
        };

        window.confirmSave = async () => {
            if(mediaRecorder) mediaRecorder.stop();
            window.closeAllOverlays();
            loader.classList.add('active');
            const titleInput = document.getElementById('recTitleInput').value.trim();
            const title = titleInput || "ç„¡é¡Œ";
            try {
                const blob = new Blob(masterAudioChunks, { type: 'audio/webm' });
                const fileSize = blob.size; 
                const fileName = `${Date.now()}.webm`;
                const storageRef = ref(storage, `audio/${fileName}`);
                await uploadBytes(storageRef, blob);
                const url = await getDownloadURL(storageRef);
                const now = new Date();
                const dateStr = `${(now.getMonth()+1).toString().padStart(2,'0')}/${now.getDate().toString().padStart(2,'0')}/${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}/${now.getFullYear()}`;
                const fullDisplayName = `${title}_${dateStr}`;
                const nowISO = now.toISOString();

                await addDoc(collection(db, "recordings"), {
                    folder: targetFolder, url: url, storagePath: `audio/${fileName}`,
                    filesize: fileSize, date: nowISO, title: title, displayName: fullDisplayName, isDeleted: false, memo: ""
                });
                await updateDoc(doc(db, "folders", targetFolder), { lastUpdatedAt: nowISO });
                masterAudioChunks = [];
            } catch (e) { alert("ä¿å­˜å¤±æ•—: " + e.message); } finally { loader.classList.remove('active'); }
        };

        window.confirmDiscard = () => {
            if(confirm("ç ´æ£„ã—ã¾ã™ã‹ï¼Ÿ")) {
                if(mediaRecorder) mediaRecorder.stop();
                window.closeAllOverlays();
                masterAudioChunks = [];
            }
        };

        window.deleteFolder = async (name) => {
            if(!confirm(`ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${name}ã€ã¨ä¸­ã®éŒ²éŸ³ã‚’å…¨ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
            loader.classList.add('active');
            await deleteDoc(doc(db, "folders", name));
            loader.classList.remove('active');
        };
        function startTimer() { startTime = Date.now(); timerInterval = setInterval(() => { const diff = Date.now() - startTime + elapsedTime; const m = Math.floor(diff/60000).toString().padStart(2,'0'); const s = Math.floor((diff%60000)/1000).toString().padStart(2,'0'); document.getElementById('timer').textContent = `${m}:${s}`; }, 1000); }
        function stopTimer() { clearInterval(timerInterval); elapsedTime += Date.now() - startTime; }

    </script>
</body>
</html>
